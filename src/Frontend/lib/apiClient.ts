//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {

    /**
     * Lists all administrators with pagination
     * @param searchTerm (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    admins(searchTerm?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Promise<AdminDtoPagedResponse>;

    /**
     * Retrieves admin dashboard with system statistics
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    dashboard(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<AdminDashboardDto>;

    /**
     * Authenticates user and returns JWT token
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginCommand | undefined): Promise<AuthResult>;

    /**
     * Refreshes expired JWT token using refresh token
     * @param body (optional) 
     * @return Success
     */
    refresh(body?: RefreshTokenCommand | undefined): Promise<AuthResult>;

    /**
     * Changes authenticated user's password
     * @param body (optional) 
     * @return Success
     */
    changePassword(body?: ChangePasswordCommand | undefined): Promise<void>;

    /**
     * Initiates password reset process via email
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body?: ForgotPasswordCommand | undefined): Promise<void>;

    /**
     * Resets user password using reset token
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body?: ResetPasswordCommand | undefined): Promise<void>;

    /**
     * Sends email verification link to user
     * @param body (optional) 
     * @return Success
     */
    send(body?: SendVerificationEmailCommand | undefined): Promise<void>;

    /**
     * Confirms user email address using verification token
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirm(userId?: string | undefined, token?: string | undefined): Promise<void>;

    /**
     * Sends OTP code to phone for verification
     * @param body (optional) 
     * @return Success
     */
    sendOtp(body?: SendOtpCommand | undefined): Promise<void>;

    /**
     * Verifies phone number using OTP code
     * @param body (optional) 
     * @return Success
     */
    confirmOtp(body?: VerifyOtpCommand | undefined): Promise<void>;

    /**
     * Authenticates user via Google OAuth
     * @param body (optional) 
     * @return Success
     */
    google(body?: ExternalAuthRequest | undefined): Promise<AuthResult>;

    /**
     * Retrieves authenticated customer's shopping cart
     * @return Success
     */
    cartGET(): Promise<void>;

    /**
     * Clears all items from customer's cart
     * @return Success
     */
    cartDELETE(): Promise<void>;

    /**
     * Adds a service to customer's cart
     * @param body (optional) 
     * @return Success
     */
    itemsPOST(body?: AddToCartDto | undefined): Promise<void>;

    /**
     * Removes a service from customer's cart
     * @return Success
     */
    itemsDELETE(serviceId: string): Promise<void>;

    /**
     * Checks out cart and creates an order
     * @param body (optional) 
     * @return Success
     */
    checkout(body?: CartCheckoutRequest | undefined): Promise<void>;

    /**
     * Creates immediate order without cart
     * @param body (optional) 
     * @return Success
     */
    buyNow(body?: BuyNowRequest | undefined): Promise<void>;

    /**
     * Lists all service categories with pagination
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    categories(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<CategoryDtoPagedResponse>;

    /**
     * Lists all customers (Admin only)
     * @param nameFilter (optional) 
     * @param emailFilter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    customers(nameFilter?: string | undefined, emailFilter?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Promise<CustomerDtoPagedResponse>;

    /**
     * Registers a new customer account
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterCustomerCommand | undefined): Promise<AuthResult>;

    /**
     * Retrieves customer dashboard with orders and wallet info
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    dashboard2(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<CustomerDashboardDto>;

    /**
     * Retrieves authenticated customer's profile
     * @return Success
     */
    meGET(): Promise<CustomerDto>;

    /**
     * Updates authenticated customer's profile
     * @param body (optional) 
     * @return No Content
     */
    mePUT(body?: CustomerUpdateRequest | undefined): Promise<void>;

    /**
     * Tops up customer's wallet balance
     * @param body (optional) 
     * @return Success
     */
    topup(body?: WalletTopUpRequest | undefined): Promise<void>;

    /**
     * Submits driver application
     * @param body (optional) 
     * @return Created
     */
    register2(body?: DriverApplicationRequest | undefined): Promise<string>;

    /**
     * Retrieves authenticated driver's profile
     * @return Success
     */
    profileGET(): Promise<DriverDto>;

    /**
     * Updates authenticated driver's profile
     * @param body (optional) 
     * @return No Content
     */
    profilePUT(body?: DriverUpdateRequest | undefined): Promise<void>;

    /**
     * Retrieves orders assigned to authenticated driver
     * @return Success
     */
    ordersAll(): Promise<OrderDto[]>;

    /**
     * Retrieves available orders for drivers to accept
     * @return Success
     */
    available(): Promise<OrderDto[]>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    status(body?: DriverStatusUpdateDto | undefined): Promise<void>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    location(body?: LocationDto | undefined): Promise<void>;

    /**
     * @return Created
     */
    apply(orderId: string): Promise<string>;

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(applicationId: string, body?: ApproveDriverRequest | undefined): Promise<string>;

    /**
     * @return Success
     */
    orderApplications(orderId: string): Promise<void>;

    /**
     * @return Success
     */
    accept(applicationId: string): Promise<void>;

    /**
     * @param body (optional) 
     * @return Success
     */
    assign(body?: AssignDriverCommand | undefined): Promise<void>;

    /**
     * Creates a new laundry order
     * @param body (optional) 
     * @return Created
     */
    ordersPOST(body?: CreateOrderDto | undefined): Promise<OrderDto>;

    /**
     * Retrieves order details by ID
     * @return Success
     */
    ordersGET(id: string): Promise<OrderDto>;

    /**
     * Lists all orders for authenticated customer
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    customer(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<OrderDtoPagedResponse>;

    /**
     * Cancels an existing order
     * @return Success
     */
    cancel(id: string): Promise<OrderDto>;

    /**
     * Processes Paymob payment webhook notifications
     * @param hmac_SHA512 (optional) 
     * @param body (optional) 
     * @return Success
     */
    webhook(hmac_SHA512?: string | undefined, body?: PaymobProcessedCallbackData | undefined): Promise<void>;

    /**
     * Health check endpoint for payment service
     * @return Success
     */
    health(): Promise<void>;

    /**
     * Creates a new review for a service
     * @param body (optional) 
     * @return Created
     */
    reviews(body?: CreateReviewDto | undefined): Promise<string>;

    /**
     * Retrieves all reviews for a specific driver
     * @return Success
     */
    driver(driverId: string): Promise<ReviewDto[]>;

    /**
     * Retrieves all reviews by authenticated customer
     * @return Success
     */
    customerAll(): Promise<ReviewDto[]>;

    /**
     * Lists all reviews (admin only)
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    all(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<ReviewDtoPagedResponse>;

    /**
     * Lists all services with optional search and pagination
     * @param nameSearchTerm (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    services(nameSearchTerm?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Promise<ServiceDtoPagedResponse>;

    /**
     * Retrieves a specific service by ID
     * @return Success
     */
    services2(id: string): Promise<ServiceDto>;

    /**
     * Retrieves featured services for homepage
     * @param count (optional) 
     * @return Success
     */
    featured(count?: number | undefined): Promise<ServiceDto[]>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Lists all administrators with pagination
     * @param searchTerm (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    admins(searchTerm?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Promise<AdminDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/admins?";
        if (searchTerm === null)
            throw new globalThis.Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmins(_response);
        });
    }

    protected processAdmins(response: Response): Promise<AdminDtoPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDtoPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminDtoPagedResponse>(null as any);
    }

    /**
     * Retrieves admin dashboard with system statistics
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    dashboard(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<AdminDashboardDto> {
        let url_ = this.baseUrl + "/api/admins/dashboard?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDashboard(_response);
        });
    }

    protected processDashboard(response: Response): Promise<AdminDashboardDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminDashboardDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminDashboardDto>(null as any);
    }

    /**
     * Authenticates user and returns JWT token
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginCommand | undefined): Promise<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AuthResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResult>(null as any);
    }

    /**
     * Refreshes expired JWT token using refresh token
     * @param body (optional) 
     * @return Success
     */
    refresh(body?: RefreshTokenCommand | undefined): Promise<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<AuthResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResult>(null as any);
    }

    /**
     * Changes authenticated user's password
     * @param body (optional) 
     * @return Success
     */
    changePassword(body?: ChangePasswordCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Initiates password reset process via email
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body?: ForgotPasswordCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Resets user password using reset token
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body?: ResetPasswordCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Sends email verification link to user
     * @param body (optional) 
     * @return Success
     */
    send(body?: SendVerificationEmailCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/verify-email/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSend(_response);
        });
    }

    protected processSend(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Confirms user email address using verification token
     * @param userId (optional) 
     * @param token (optional) 
     * @return Success
     */
    confirm(userId?: string | undefined, token?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/verify-email/confirm?";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (token === null)
            throw new globalThis.Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "Token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirm(_response);
        });
    }

    protected processConfirm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Sends OTP code to phone for verification
     * @param body (optional) 
     * @return Success
     */
    sendOtp(body?: SendOtpCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/verify-phone/send-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendOtp(_response);
        });
    }

    protected processSendOtp(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Verifies phone number using OTP code
     * @param body (optional) 
     * @return Success
     */
    confirmOtp(body?: VerifyOtpCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Auth/verify-phone/confirm-otp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmOtp(_response);
        });
    }

    protected processConfirmOtp(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Authenticates user via Google OAuth
     * @param body (optional) 
     * @return Success
     */
    google(body?: ExternalAuthRequest | undefined): Promise<AuthResult> {
        let url_ = this.baseUrl + "/api/Auth/external/google";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGoogle(_response);
        });
    }

    protected processGoogle(response: Response): Promise<AuthResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResult>(null as any);
    }

    /**
     * Retrieves authenticated customer's shopping cart
     * @return Success
     */
    cartGET(): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCartGET(_response);
        });
    }

    protected processCartGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Clears all items from customer's cart
     * @return Success
     */
    cartDELETE(): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCartDELETE(_response);
        });
    }

    protected processCartDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Adds a service to customer's cart
     * @param body (optional) 
     * @return Success
     */
    itemsPOST(body?: AddToCartDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/cart/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsPOST(_response);
        });
    }

    protected processItemsPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Removes a service from customer's cart
     * @return Success
     */
    itemsDELETE(serviceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/cart/items/{serviceId}";
        if (serviceId === undefined || serviceId === null)
            throw new globalThis.Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItemsDELETE(_response);
        });
    }

    protected processItemsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Checks out cart and creates an order
     * @param body (optional) 
     * @return Success
     */
    checkout(body?: CartCheckoutRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/cart/checkout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckout(_response);
        });
    }

    protected processCheckout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Creates immediate order without cart
     * @param body (optional) 
     * @return Success
     */
    buyNow(body?: BuyNowRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/cart/buy-now";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBuyNow(_response);
        });
    }

    protected processBuyNow(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Lists all service categories with pagination
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    categories(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<CategoryDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/categories?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategories(_response);
        });
    }

    protected processCategories(response: Response): Promise<CategoryDtoPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryDtoPagedResponse>(null as any);
    }

    /**
     * Lists all customers (Admin only)
     * @param nameFilter (optional) 
     * @param emailFilter (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    customers(nameFilter?: string | undefined, emailFilter?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Promise<CustomerDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/customers?";
        if (nameFilter === null)
            throw new globalThis.Error("The parameter 'nameFilter' cannot be null.");
        else if (nameFilter !== undefined)
            url_ += "nameFilter=" + encodeURIComponent("" + nameFilter) + "&";
        if (emailFilter === null)
            throw new globalThis.Error("The parameter 'emailFilter' cannot be null.");
        else if (emailFilter !== undefined)
            url_ += "emailFilter=" + encodeURIComponent("" + emailFilter) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomers(_response);
        });
    }

    protected processCustomers(response: Response): Promise<CustomerDtoPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDtoPagedResponse>(null as any);
    }

    /**
     * Registers a new customer account
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterCustomerCommand | undefined): Promise<AuthResult> {
        let url_ = this.baseUrl + "/api/customers/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<AuthResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResult>(null as any);
    }

    /**
     * Retrieves customer dashboard with orders and wallet info
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    dashboard2(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<CustomerDashboardDto> {
        let url_ = this.baseUrl + "/api/customers/dashboard?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDashboard2(_response);
        });
    }

    protected processDashboard2(response: Response): Promise<CustomerDashboardDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDashboardDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDashboardDto>(null as any);
    }

    /**
     * Retrieves authenticated customer's profile
     * @return Success
     */
    meGET(): Promise<CustomerDto> {
        let url_ = this.baseUrl + "/api/customers/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeGET(_response);
        });
    }

    protected processMeGET(response: Response): Promise<CustomerDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDto>(null as any);
    }

    /**
     * Updates authenticated customer's profile
     * @param body (optional) 
     * @return No Content
     */
    mePUT(body?: CustomerUpdateRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMePUT(_response);
        });
    }

    protected processMePUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Tops up customer's wallet balance
     * @param body (optional) 
     * @return Success
     */
    topup(body?: WalletTopUpRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/customers/topup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTopup(_response);
        });
    }

    protected processTopup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Submits driver application
     * @param body (optional) 
     * @return Created
     */
    register2(body?: DriverApplicationRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Drivers/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister2(_response);
        });
    }

    protected processRegister2(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : null as any;
    
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Retrieves authenticated driver's profile
     * @return Success
     */
    profileGET(): Promise<DriverDto> {
        let url_ = this.baseUrl + "/api/Drivers/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfileGET(_response);
        });
    }

    protected processProfileGET(response: Response): Promise<DriverDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DriverDto>(null as any);
    }

    /**
     * Updates authenticated driver's profile
     * @param body (optional) 
     * @return No Content
     */
    profilePUT(body?: DriverUpdateRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Drivers/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilePUT(_response);
        });
    }

    protected processProfilePUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retrieves orders assigned to authenticated driver
     * @return Success
     */
    ordersAll(): Promise<OrderDto[]> {
        let url_ = this.baseUrl + "/api/Drivers/orders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersAll(_response);
        });
    }

    protected processOrdersAll(response: Response): Promise<OrderDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto[]>(null as any);
    }

    /**
     * Retrieves available orders for drivers to accept
     * @return Success
     */
    available(): Promise<OrderDto[]> {
        let url_ = this.baseUrl + "/api/Drivers/available";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAvailable(_response);
        });
    }

    protected processAvailable(response: Response): Promise<OrderDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    status(body?: DriverStatusUpdateDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Drivers/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    location(body?: LocationDto | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Drivers/location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLocation(_response);
        });
    }

    protected processLocation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Created
     */
    apply(orderId: string): Promise<string> {
        let url_ = this.baseUrl + "/api/Drivers/apply/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApply(_response);
        });
    }

    protected processApply(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : null as any;
    
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approve(applicationId: string, body?: ApproveDriverRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Drivers/admin/applications/{applicationId}/approve";
        if (applicationId === undefined || applicationId === null)
            throw new globalThis.Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    orderApplications(orderId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Drivers/admin/order-applications/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderApplications(_response);
        });
    }

    protected processOrderApplications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    accept(applicationId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Drivers/admin/applications/{applicationId}/accept";
        if (applicationId === undefined || applicationId === null)
            throw new globalThis.Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccept(_response);
        });
    }

    protected processAccept(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assign(body?: AssignDriverCommand | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Drivers/admin/assign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssign(_response);
        });
    }

    protected processAssign(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Creates a new laundry order
     * @param body (optional) 
     * @return Created
     */
    ordersPOST(body?: CreateOrderDto | undefined): Promise<OrderDto> {
        let url_ = this.baseUrl + "/api/orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersPOST(_response);
        });
    }

    protected processOrdersPOST(response: Response): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OrderDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * Retrieves order details by ID
     * @return Success
     */
    ordersGET(id: string): Promise<OrderDto> {
        let url_ = this.baseUrl + "/api/orders/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrdersGET(_response);
        });
    }

    protected processOrdersGET(response: Response): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * Lists all orders for authenticated customer
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    customer(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<OrderDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/orders/customer?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomer(_response);
        });
    }

    protected processCustomer(response: Response): Promise<OrderDtoPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDtoPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDtoPagedResponse>(null as any);
    }

    /**
     * Cancels an existing order
     * @return Success
     */
    cancel(id: string): Promise<OrderDto> {
        let url_ = this.baseUrl + "/api/orders/{id}/cancel";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<OrderDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * Processes Paymob payment webhook notifications
     * @param hmac_SHA512 (optional) 
     * @param body (optional) 
     * @return Success
     */
    webhook(hmac_SHA512?: string | undefined, body?: PaymobProcessedCallbackData | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Payments/webhook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Hmac-SHA512": hmac_SHA512 !== undefined && hmac_SHA512 !== null ? "" + hmac_SHA512 : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWebhook(_response);
        });
    }

    protected processWebhook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Health check endpoint for payment service
     * @return Success
     */
    health(): Promise<void> {
        let url_ = this.baseUrl + "/api/Payments/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Creates a new review for a service
     * @param body (optional) 
     * @return Created
     */
    reviews(body?: CreateReviewDto | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Reviews";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReviews(_response);
        });
    }

    protected processReviews(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : null as any;
    
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Retrieves all reviews for a specific driver
     * @return Success
     */
    driver(driverId: string): Promise<ReviewDto[]> {
        let url_ = this.baseUrl + "/api/Reviews/driver/{driverId}";
        if (driverId === undefined || driverId === null)
            throw new globalThis.Error("The parameter 'driverId' must be defined.");
        url_ = url_.replace("{driverId}", encodeURIComponent("" + driverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDriver(_response);
        });
    }

    protected processDriver(response: Response): Promise<ReviewDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReviewDto[]>(null as any);
    }

    /**
     * Retrieves all reviews by authenticated customer
     * @return Success
     */
    customerAll(): Promise<ReviewDto[]> {
        let url_ = this.baseUrl + "/api/Reviews/customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCustomerAll(_response);
        });
    }

    protected processCustomerAll(response: Response): Promise<ReviewDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReviewDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReviewDto[]>(null as any);
    }

    /**
     * Lists all reviews (admin only)
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    all(pageNumber?: number | undefined, pageSize?: number | undefined): Promise<ReviewDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Reviews/admin/all?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: Response): Promise<ReviewDtoPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReviewDtoPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReviewDtoPagedResponse>(null as any);
    }

    /**
     * Lists all services with optional search and pagination
     * @param nameSearchTerm (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    services(nameSearchTerm?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Promise<ServiceDtoPagedResponse> {
        let url_ = this.baseUrl + "/api/Services?";
        if (nameSearchTerm === null)
            throw new globalThis.Error("The parameter 'nameSearchTerm' cannot be null.");
        else if (nameSearchTerm !== undefined)
            url_ += "nameSearchTerm=" + encodeURIComponent("" + nameSearchTerm) + "&";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processServices(_response);
        });
    }

    protected processServices(response: Response): Promise<ServiceDtoPagedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDtoPagedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceDtoPagedResponse>(null as any);
    }

    /**
     * Retrieves a specific service by ID
     * @return Success
     */
    services2(id: string): Promise<ServiceDto> {
        let url_ = this.baseUrl + "/api/Services/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processServices2(_response);
        });
    }

    protected processServices2(response: Response): Promise<ServiceDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServiceDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceDto>(null as any);
    }

    /**
     * Retrieves featured services for homepage
     * @param count (optional) 
     * @return Success
     */
    featured(count?: number | undefined): Promise<ServiceDto[]> {
        let url_ = this.baseUrl + "/api/Services/featured?";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFeatured(_response);
        });
    }

    protected processFeatured(response: Response): Promise<ServiceDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServiceDto[]>(null as any);
    }
}

export class AddToCartDto implements IAddToCartDto {
    serviceId?: string;
    quantity?: number;

    constructor(data?: IAddToCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceId = _data["serviceId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddToCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddToCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IAddToCartDto {
    serviceId?: string;
    quantity?: number;
}

export class AdminDashboardDto implements IAdminDashboardDto {
    totalOrdersToday?: number;
    revenueToday?: number;
    revenueCurrency?: string | undefined;
    mostUsedServices?: MostUsedServiceDto[] | undefined;
    numberOfActiveCleaners?: number;
    newRegistrationsToday?: number;
    pendingBookings?: number;

    constructor(data?: IAdminDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalOrdersToday = _data["totalOrdersToday"];
            this.revenueToday = _data["revenueToday"];
            this.revenueCurrency = _data["revenueCurrency"];
            if (Array.isArray(_data["mostUsedServices"])) {
                this.mostUsedServices = [] as any;
                for (let item of _data["mostUsedServices"])
                    this.mostUsedServices!.push(MostUsedServiceDto.fromJS(item));
            }
            this.numberOfActiveCleaners = _data["numberOfActiveCleaners"];
            this.newRegistrationsToday = _data["newRegistrationsToday"];
            this.pendingBookings = _data["pendingBookings"];
        }
    }

    static fromJS(data: any): AdminDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrdersToday"] = this.totalOrdersToday;
        data["revenueToday"] = this.revenueToday;
        data["revenueCurrency"] = this.revenueCurrency;
        if (Array.isArray(this.mostUsedServices)) {
            data["mostUsedServices"] = [];
            for (let item of this.mostUsedServices)
                data["mostUsedServices"].push(item ? item.toJSON() : undefined as any);
        }
        data["numberOfActiveCleaners"] = this.numberOfActiveCleaners;
        data["newRegistrationsToday"] = this.newRegistrationsToday;
        data["pendingBookings"] = this.pendingBookings;
        return data;
    }
}

export interface IAdminDashboardDto {
    totalOrdersToday?: number;
    revenueToday?: number;
    revenueCurrency?: string | undefined;
    mostUsedServices?: MostUsedServiceDto[] | undefined;
    numberOfActiveCleaners?: number;
    newRegistrationsToday?: number;
    pendingBookings?: number;
}

export class AdminDto implements IAdminDto {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    adminRole?: string | undefined;

    constructor(data?: IAdminDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.adminRole = _data["adminRole"];
        }
    }

    static fromJS(data: any): AdminDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["adminRole"] = this.adminRole;
        return data;
    }
}

export interface IAdminDto {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    adminRole?: string | undefined;
}

export class AdminDtoPagedResponse implements IAdminDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    readonly totalPages?: number;
    totalRecords?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    data?: AdminDto[] | undefined;

    constructor(data?: IAdminDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            (this as any).totalPages = _data["totalPages"];
            this.totalRecords = _data["totalRecords"];
            (this as any).hasPreviousPage = _data["hasPreviousPage"];
            (this as any).hasNextPage = _data["hasNextPage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AdminDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdminDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AdminDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalRecords"] = this.totalRecords;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAdminDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    totalRecords?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    data?: AdminDto[] | undefined;
}

export class ApproveDriverRequest implements IApproveDriverRequest {
    password?: string | undefined;

    constructor(data?: IApproveDriverRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ApproveDriverRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveDriverRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        return data;
    }
}

export interface IApproveDriverRequest {
    password?: string | undefined;
}

export class AssignDriverCommand implements IAssignDriverCommand {
    orderId?: string;
    driverId?: string;
    adminId?: string;

    constructor(data?: IAssignDriverCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.driverId = _data["driverId"];
            this.adminId = _data["adminId"];
        }
    }

    static fromJS(data: any): AssignDriverCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignDriverCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["driverId"] = this.driverId;
        data["adminId"] = this.adminId;
        return data;
    }
}

export interface IAssignDriverCommand {
    orderId?: string;
    driverId?: string;
    adminId?: string;
}

export class AuthResult implements IAuthResult {
    userId?: string;
    email?: string | undefined;
    accessToken?: string | undefined;
    accessTokenExpiration?: Date;
    refreshToken?: string | undefined;
    refreshTokenExpiration?: Date;

    constructor(data?: IAuthResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.accessToken = _data["accessToken"];
            this.accessTokenExpiration = _data["accessTokenExpiration"] ? new Date(_data["accessTokenExpiration"].toString()) : undefined as any;
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"] ? new Date(_data["refreshTokenExpiration"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): AuthResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["accessToken"] = this.accessToken;
        data["accessTokenExpiration"] = this.accessTokenExpiration ? this.accessTokenExpiration.toISOString() : undefined as any;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration ? this.refreshTokenExpiration.toISOString() : undefined as any;
        return data;
    }
}

export interface IAuthResult {
    userId?: string;
    email?: string | undefined;
    accessToken?: string | undefined;
    accessTokenExpiration?: Date;
    refreshToken?: string | undefined;
    refreshTokenExpiration?: Date;
}

export class BuyNowRequest implements IBuyNowRequest {
    serviceId?: string;
    quantity?: number;
    timeSlotId?: string;
    scheduledDate?: Date;
    paymentMethod?: PaymentMethod;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;

    constructor(data?: IBuyNowRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceId = _data["serviceId"];
            this.quantity = _data["quantity"];
            this.timeSlotId = _data["timeSlotId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : undefined as any;
            this.paymentMethod = _data["paymentMethod"];
            this.pickupLatitude = _data["pickupLatitude"];
            this.pickupLongitude = _data["pickupLongitude"];
            this.deliveryLatitude = _data["deliveryLatitude"];
            this.deliveryLongitude = _data["deliveryLongitude"];
        }
    }

    static fromJS(data: any): BuyNowRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BuyNowRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["quantity"] = this.quantity;
        data["timeSlotId"] = this.timeSlotId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : undefined as any;
        data["paymentMethod"] = this.paymentMethod;
        data["pickupLatitude"] = this.pickupLatitude;
        data["pickupLongitude"] = this.pickupLongitude;
        data["deliveryLatitude"] = this.deliveryLatitude;
        data["deliveryLongitude"] = this.deliveryLongitude;
        return data;
    }
}

export interface IBuyNowRequest {
    serviceId?: string;
    quantity?: number;
    timeSlotId?: string;
    scheduledDate?: Date;
    paymentMethod?: PaymentMethod;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;
}

export class CartCheckoutRequest implements ICartCheckoutRequest {
    timeSlotId?: string;
    scheduledDate?: Date;
    paymentMethod?: PaymentMethod;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;

    constructor(data?: ICartCheckoutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeSlotId = _data["timeSlotId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : undefined as any;
            this.paymentMethod = _data["paymentMethod"];
            this.pickupLatitude = _data["pickupLatitude"];
            this.pickupLongitude = _data["pickupLongitude"];
            this.deliveryLatitude = _data["deliveryLatitude"];
            this.deliveryLongitude = _data["deliveryLongitude"];
        }
    }

    static fromJS(data: any): CartCheckoutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CartCheckoutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSlotId"] = this.timeSlotId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : undefined as any;
        data["paymentMethod"] = this.paymentMethod;
        data["pickupLatitude"] = this.pickupLatitude;
        data["pickupLongitude"] = this.pickupLongitude;
        data["deliveryLatitude"] = this.deliveryLatitude;
        data["deliveryLongitude"] = this.deliveryLongitude;
        return data;
    }
}

export interface ICartCheckoutRequest {
    timeSlotId?: string;
    scheduledDate?: Date;
    paymentMethod?: PaymentMethod;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;
}

export class CategoryDto implements ICategoryDto {
    id?: string;
    name?: string | undefined;
    price?: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        return data;
    }
}

export interface ICategoryDto {
    id?: string;
    name?: string | undefined;
    price?: number;
}

export class CategoryDtoPagedResponse implements ICategoryDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    readonly totalPages?: number;
    totalRecords?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    data?: CategoryDto[] | undefined;

    constructor(data?: ICategoryDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            (this as any).totalPages = _data["totalPages"];
            this.totalRecords = _data["totalRecords"];
            (this as any).hasPreviousPage = _data["hasPreviousPage"];
            (this as any).hasNextPage = _data["hasNextPage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalRecords"] = this.totalRecords;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICategoryDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    totalRecords?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    data?: CategoryDto[] | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
    userId?: string;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordCommand {
    userId?: string;
    currentPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class CreateOrderDto implements ICreateOrderDto {
    timeSlotId?: string;
    scheduledDate?: Date;
    paymentMethod?: PaymentMethod;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;
    items?: CreateOrderItemDto[] | undefined;

    constructor(data?: ICreateOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeSlotId = _data["timeSlotId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : undefined as any;
            this.paymentMethod = _data["paymentMethod"];
            this.pickupLatitude = _data["pickupLatitude"];
            this.pickupLongitude = _data["pickupLongitude"];
            this.deliveryLatitude = _data["deliveryLatitude"];
            this.deliveryLongitude = _data["deliveryLongitude"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CreateOrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeSlotId"] = this.timeSlotId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : undefined as any;
        data["paymentMethod"] = this.paymentMethod;
        data["pickupLatitude"] = this.pickupLatitude;
        data["pickupLongitude"] = this.pickupLongitude;
        data["deliveryLatitude"] = this.deliveryLatitude;
        data["deliveryLongitude"] = this.deliveryLongitude;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateOrderDto {
    timeSlotId?: string;
    scheduledDate?: Date;
    paymentMethod?: PaymentMethod;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;
    items?: CreateOrderItemDto[] | undefined;
}

export class CreateOrderItemDto implements ICreateOrderItemDto {
    serviceId?: string;
    itemName?: string | undefined;
    quantity?: number;

    constructor(data?: ICreateOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceId = _data["serviceId"];
            this.itemName = _data["itemName"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["itemName"] = this.itemName;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateOrderItemDto {
    serviceId?: string;
    itemName?: string | undefined;
    quantity?: number;
}

export class CreateReviewDto implements ICreateReviewDto {
    orderId?: string;
    rating?: number;
    comment?: string | undefined;

    constructor(data?: ICreateReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.rating = _data["rating"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["rating"] = this.rating;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ICreateReviewDto {
    orderId?: string;
    rating?: number;
    comment?: string | undefined;
}

export class CustomerDashboardDto implements ICustomerDashboardDto {
    totalOrders?: number;
    upcomingBookedServices?: number;
    walletBalance?: number;
    walletCurrency?: string | undefined;
    upcomingOrders?: OrderDto[] | undefined;
    recentTransactions?: PaymentDto[] | undefined;
    totalReviewsSent?: number;

    constructor(data?: ICustomerDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalOrders = _data["totalOrders"];
            this.upcomingBookedServices = _data["upcomingBookedServices"];
            this.walletBalance = _data["walletBalance"];
            this.walletCurrency = _data["walletCurrency"];
            if (Array.isArray(_data["upcomingOrders"])) {
                this.upcomingOrders = [] as any;
                for (let item of _data["upcomingOrders"])
                    this.upcomingOrders!.push(OrderDto.fromJS(item));
            }
            if (Array.isArray(_data["recentTransactions"])) {
                this.recentTransactions = [] as any;
                for (let item of _data["recentTransactions"])
                    this.recentTransactions!.push(PaymentDto.fromJS(item));
            }
            this.totalReviewsSent = _data["totalReviewsSent"];
        }
    }

    static fromJS(data: any): CustomerDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrders"] = this.totalOrders;
        data["upcomingBookedServices"] = this.upcomingBookedServices;
        data["walletBalance"] = this.walletBalance;
        data["walletCurrency"] = this.walletCurrency;
        if (Array.isArray(this.upcomingOrders)) {
            data["upcomingOrders"] = [];
            for (let item of this.upcomingOrders)
                data["upcomingOrders"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.recentTransactions)) {
            data["recentTransactions"] = [];
            for (let item of this.recentTransactions)
                data["recentTransactions"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalReviewsSent"] = this.totalReviewsSent;
        return data;
    }
}

export interface ICustomerDashboardDto {
    totalOrders?: number;
    upcomingBookedServices?: number;
    walletBalance?: number;
    walletCurrency?: string | undefined;
    upcomingOrders?: OrderDto[] | undefined;
    recentTransactions?: PaymentDto[] | undefined;
    totalReviewsSent?: number;
}

export class CustomerDto implements ICustomerDto {
    id?: string;
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
    walletBalance?: number;
    walletCurrency?: string | undefined;
    type?: CustomerType;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
            this.walletBalance = _data["walletBalance"];
            this.walletCurrency = _data["walletCurrency"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["street"] = this.street;
        data["city"] = this.city;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        data["walletBalance"] = this.walletBalance;
        data["walletCurrency"] = this.walletCurrency;
        data["type"] = this.type;
        return data;
    }
}

export interface ICustomerDto {
    id?: string;
    name?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
    walletBalance?: number;
    walletCurrency?: string | undefined;
    type?: CustomerType;
}

export class CustomerDtoPagedResponse implements ICustomerDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    readonly totalPages?: number;
    totalRecords?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    data?: CustomerDto[] | undefined;

    constructor(data?: ICustomerDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            (this as any).totalPages = _data["totalPages"];
            this.totalRecords = _data["totalRecords"];
            (this as any).hasPreviousPage = _data["hasPreviousPage"];
            (this as any).hasNextPage = _data["hasNextPage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalRecords"] = this.totalRecords;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICustomerDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    totalRecords?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    data?: CustomerDto[] | undefined;
}

export enum CustomerType {
    _0 = 0,
    _1 = 1,
}

export class CustomerUpdateRequest implements ICustomerUpdateRequest {
    name?: string | undefined;
    phone?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: ICustomerUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): CustomerUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["street"] = this.street;
        data["city"] = this.city;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        return data;
    }
}

export interface ICustomerUpdateRequest {
    name?: string | undefined;
    phone?: string | undefined;
    street?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
}

export class DriverApplicationRequest implements IDriverApplicationRequest {
    email?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    vehicleInfo?: string | undefined;

    constructor(data?: IDriverApplicationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.vehicleInfo = _data["vehicleInfo"];
        }
    }

    static fromJS(data: any): DriverApplicationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DriverApplicationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["vehicleInfo"] = this.vehicleInfo;
        return data;
    }
}

export interface IDriverApplicationRequest {
    email?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    vehicleInfo?: string | undefined;
}

export class DriverDto implements IDriverDto {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    vehicleInfo?: string | undefined;
    status?: string | undefined;
    currentLocation?: LocationDto;

    constructor(data?: IDriverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.vehicleInfo = _data["vehicleInfo"];
            this.status = _data["status"];
            this.currentLocation = _data["currentLocation"] ? LocationDto.fromJS(_data["currentLocation"]) : undefined as any;
        }
    }

    static fromJS(data: any): DriverDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["vehicleInfo"] = this.vehicleInfo;
        data["status"] = this.status;
        data["currentLocation"] = this.currentLocation ? this.currentLocation.toJSON() : undefined as any;
        return data;
    }
}

export interface IDriverDto {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    vehicleInfo?: string | undefined;
    status?: string | undefined;
    currentLocation?: LocationDto;
}

export class DriverStatusUpdateDto implements IDriverStatusUpdateDto {
    status?: string | undefined;

    constructor(data?: IDriverStatusUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DriverStatusUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverStatusUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IDriverStatusUpdateDto {
    status?: string | undefined;
}

export class DriverUpdateRequest implements IDriverUpdateRequest {
    name?: string | undefined;
    phone?: string | undefined;
    vehicleInfo?: string | undefined;

    constructor(data?: IDriverUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.vehicleInfo = _data["vehicleInfo"];
        }
    }

    static fromJS(data: any): DriverUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DriverUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["vehicleInfo"] = this.vehicleInfo;
        return data;
    }
}

export interface IDriverUpdateRequest {
    name?: string | undefined;
    phone?: string | undefined;
    vehicleInfo?: string | undefined;
}

export class ExternalAuthRequest implements IExternalAuthRequest {
    provider?: string | undefined;
    idToken?: string | undefined;

    constructor(data?: IExternalAuthRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.idToken = _data["idToken"];
        }
    }

    static fromJS(data: any): ExternalAuthRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["idToken"] = this.idToken;
        return data;
    }
}

export interface IExternalAuthRequest {
    provider?: string | undefined;
    idToken?: string | undefined;
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    email?: string | undefined;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordCommand {
    email?: string | undefined;
}

export class LocationDto implements ILocationDto {
    latitude?: number;
    longitude?: number;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface ILocationDto {
    latitude?: number;
    longitude?: number;
}

export class LoginCommand implements ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginCommand {
    email?: string | undefined;
    password?: string | undefined;
}

export class MostUsedServiceDto implements IMostUsedServiceDto {
    serviceId?: string;
    serviceName?: string | undefined;
    orderCount?: number;

    constructor(data?: IMostUsedServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceId = _data["serviceId"];
            this.serviceName = _data["serviceName"];
            this.orderCount = _data["orderCount"];
        }
    }

    static fromJS(data: any): MostUsedServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new MostUsedServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId;
        data["serviceName"] = this.serviceName;
        data["orderCount"] = this.orderCount;
        return data;
    }
}

export interface IMostUsedServiceDto {
    serviceId?: string;
    serviceName?: string | undefined;
    orderCount?: number;
}

export class OrderDto implements IOrderDto {
    id?: string;
    customerId?: string;
    driverId?: string | undefined;
    timeSlotId?: string;
    scheduledDate?: Date;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;
    totalPrice?: number;
    currency?: string | undefined;
    status?: OrderStatus;
    paymentMethod?: PaymentMethod;
    orderDate?: Date;
    items?: OrderItemDto[] | undefined;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.driverId = _data["driverId"];
            this.timeSlotId = _data["timeSlotId"];
            this.scheduledDate = _data["scheduledDate"] ? new Date(_data["scheduledDate"].toString()) : undefined as any;
            this.pickupLatitude = _data["pickupLatitude"];
            this.pickupLongitude = _data["pickupLongitude"];
            this.deliveryLatitude = _data["deliveryLatitude"];
            this.deliveryLongitude = _data["deliveryLongitude"];
            this.totalPrice = _data["totalPrice"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.paymentMethod = _data["paymentMethod"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["driverId"] = this.driverId;
        data["timeSlotId"] = this.timeSlotId;
        data["scheduledDate"] = this.scheduledDate ? this.scheduledDate.toISOString() : undefined as any;
        data["pickupLatitude"] = this.pickupLatitude;
        data["pickupLongitude"] = this.pickupLongitude;
        data["deliveryLatitude"] = this.deliveryLatitude;
        data["deliveryLongitude"] = this.deliveryLongitude;
        data["totalPrice"] = this.totalPrice;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["paymentMethod"] = this.paymentMethod;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrderDto {
    id?: string;
    customerId?: string;
    driverId?: string | undefined;
    timeSlotId?: string;
    scheduledDate?: Date;
    pickupLatitude?: number;
    pickupLongitude?: number;
    deliveryLatitude?: number;
    deliveryLongitude?: number;
    totalPrice?: number;
    currency?: string | undefined;
    status?: OrderStatus;
    paymentMethod?: PaymentMethod;
    orderDate?: Date;
    items?: OrderItemDto[] | undefined;
}

export class OrderDtoPagedResponse implements IOrderDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    readonly totalPages?: number;
    totalRecords?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    data?: OrderDto[] | undefined;

    constructor(data?: IOrderDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            (this as any).totalPages = _data["totalPages"];
            this.totalRecords = _data["totalRecords"];
            (this as any).hasPreviousPage = _data["hasPreviousPage"];
            (this as any).hasNextPage = _data["hasNextPage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalRecords"] = this.totalRecords;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrderDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    totalRecords?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    data?: OrderDto[] | undefined;
}

export class OrderItemDto implements IOrderItemDto {
    id?: string;
    serviceId?: string;
    priceAmount?: number;
    priceCurrency?: string | undefined;
    quantity?: number;

    constructor(data?: IOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceId = _data["serviceId"];
            this.priceAmount = _data["priceAmount"];
            this.priceCurrency = _data["priceCurrency"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): OrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceId"] = this.serviceId;
        data["priceAmount"] = this.priceAmount;
        data["priceCurrency"] = this.priceCurrency;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IOrderItemDto {
    id?: string;
    serviceId?: string;
    priceAmount?: number;
    priceCurrency?: string | undefined;
    quantity?: number;
}

export enum OrderStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class PaymentDto implements IPaymentDto {
    id?: string;
    orderId?: string;
    amount?: number;
    currency?: string | undefined;
    paymentDate?: Date;
    method?: PaymentMethod;
    status?: PaymentStatus;

    constructor(data?: IPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderId = _data["orderId"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : undefined as any;
            this.method = _data["method"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderId"] = this.orderId;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : undefined as any;
        data["method"] = this.method;
        data["status"] = this.status;
        return data;
    }
}

export interface IPaymentDto {
    id?: string;
    orderId?: string;
    amount?: number;
    currency?: string | undefined;
    paymentDate?: Date;
    method?: PaymentMethod;
    status?: PaymentStatus;
}

export enum PaymentMethod {
    CreditCard = "CreditCard",
    DebitCard = "DebitCard",
    Fawry = "Fawry",
    PayPal = "PayPal",
    Wallet = "Wallet",
    CashOnDelivery = "CashOnDelivery",
    Paymob = "Paymob",
    Instapay = "Instapay",
}

export enum PaymentStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class PaymobProcessedCallbackData implements IPaymobProcessedCallbackData {
    amountCents?: number;
    createdAt?: string | undefined;
    currency?: string | undefined;
    errorOccured?: boolean;
    hasParentTransaction?: boolean;
    id?: number;
    integrationId?: number;
    is3dSecure?: boolean;
    isAuth?: boolean;
    isCapture?: boolean;
    isRefunded?: boolean;
    isStandalonePayment?: boolean;
    isVoided?: boolean;
    orderId?: number;
    owner?: number;
    pending?: boolean;
    sourceDataPan?: string | undefined;
    sourceDataSubType?: string | undefined;
    sourceDataType?: string | undefined;
    success?: boolean;

    constructor(data?: IPaymobProcessedCallbackData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amountCents = _data["amountCents"];
            this.createdAt = _data["createdAt"];
            this.currency = _data["currency"];
            this.errorOccured = _data["errorOccured"];
            this.hasParentTransaction = _data["hasParentTransaction"];
            this.id = _data["id"];
            this.integrationId = _data["integrationId"];
            this.is3dSecure = _data["is3dSecure"];
            this.isAuth = _data["isAuth"];
            this.isCapture = _data["isCapture"];
            this.isRefunded = _data["isRefunded"];
            this.isStandalonePayment = _data["isStandalonePayment"];
            this.isVoided = _data["isVoided"];
            this.orderId = _data["orderId"];
            this.owner = _data["owner"];
            this.pending = _data["pending"];
            this.sourceDataPan = _data["sourceDataPan"];
            this.sourceDataSubType = _data["sourceDataSubType"];
            this.sourceDataType = _data["sourceDataType"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): PaymobProcessedCallbackData {
        data = typeof data === 'object' ? data : {};
        let result = new PaymobProcessedCallbackData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountCents"] = this.amountCents;
        data["createdAt"] = this.createdAt;
        data["currency"] = this.currency;
        data["errorOccured"] = this.errorOccured;
        data["hasParentTransaction"] = this.hasParentTransaction;
        data["id"] = this.id;
        data["integrationId"] = this.integrationId;
        data["is3dSecure"] = this.is3dSecure;
        data["isAuth"] = this.isAuth;
        data["isCapture"] = this.isCapture;
        data["isRefunded"] = this.isRefunded;
        data["isStandalonePayment"] = this.isStandalonePayment;
        data["isVoided"] = this.isVoided;
        data["orderId"] = this.orderId;
        data["owner"] = this.owner;
        data["pending"] = this.pending;
        data["sourceDataPan"] = this.sourceDataPan;
        data["sourceDataSubType"] = this.sourceDataSubType;
        data["sourceDataType"] = this.sourceDataType;
        data["success"] = this.success;
        return data;
    }
}

export interface IPaymobProcessedCallbackData {
    amountCents?: number;
    createdAt?: string | undefined;
    currency?: string | undefined;
    errorOccured?: boolean;
    hasParentTransaction?: boolean;
    id?: number;
    integrationId?: number;
    is3dSecure?: boolean;
    isAuth?: boolean;
    isCapture?: boolean;
    isRefunded?: boolean;
    isStandalonePayment?: boolean;
    isVoided?: boolean;
    orderId?: number;
    owner?: number;
    pending?: boolean;
    sourceDataPan?: string | undefined;
    sourceDataSubType?: string | undefined;
    sourceDataType?: string | undefined;
    success?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
    refreshToken?: string | undefined;

    constructor(data?: IRefreshTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenCommand {
    refreshToken?: string | undefined;
}

export class RegisterCustomerCommand implements IRegisterCustomerCommand {
    email?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    type?: CustomerType;
    street?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: IRegisterCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.type = _data["type"];
            this.street = _data["street"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): RegisterCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["type"] = this.type;
        data["street"] = this.street;
        data["city"] = this.city;
        data["country"] = this.country;
        data["zipCode"] = this.zipCode;
        return data;
    }
}

export interface IRegisterCustomerCommand {
    email?: string | undefined;
    password?: string | undefined;
    name?: string | undefined;
    phone?: string | undefined;
    type?: CustomerType;
    street?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    zipCode?: string | undefined;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    userId?: string | undefined;
    token?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    userId?: string | undefined;
    token?: string | undefined;
    newPassword?: string | undefined;
}

export class ReviewDto implements IReviewDto {
    id?: string;
    customerId?: string;
    orderId?: string;
    driverId?: string | undefined;
    rating?: number;
    comment?: string | undefined;

    constructor(data?: IReviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.orderId = _data["orderId"];
            this.driverId = _data["driverId"];
            this.rating = _data["rating"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ReviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["orderId"] = this.orderId;
        data["driverId"] = this.driverId;
        data["rating"] = this.rating;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IReviewDto {
    id?: string;
    customerId?: string;
    orderId?: string;
    driverId?: string | undefined;
    rating?: number;
    comment?: string | undefined;
}

export class ReviewDtoPagedResponse implements IReviewDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    readonly totalPages?: number;
    totalRecords?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    data?: ReviewDto[] | undefined;

    constructor(data?: IReviewDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            (this as any).totalPages = _data["totalPages"];
            this.totalRecords = _data["totalRecords"];
            (this as any).hasPreviousPage = _data["hasPreviousPage"];
            (this as any).hasNextPage = _data["hasNextPage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ReviewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReviewDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalRecords"] = this.totalRecords;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IReviewDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    totalRecords?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    data?: ReviewDto[] | undefined;
}

export class SendOtpCommand implements ISendOtpCommand {
    phoneNumber?: string | undefined;

    constructor(data?: ISendOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendOtpCommand {
    phoneNumber?: string | undefined;
}

export class SendVerificationEmailCommand implements ISendVerificationEmailCommand {
    userId?: string;

    constructor(data?: ISendVerificationEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): SendVerificationEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface ISendVerificationEmailCommand {
    userId?: string;
}

export class ServiceDto implements IServiceDto {
    id?: string;
    categoryId?: string;
    name?: string | undefined;
    description?: string | undefined;
    basePrice?: number;
    estimatedDurationHours?: number;
    maxWeightKg?: number;
    isActive?: boolean;
    isFeatured?: boolean;

    constructor(data?: IServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.basePrice = _data["basePrice"];
            this.estimatedDurationHours = _data["estimatedDurationHours"];
            this.maxWeightKg = _data["maxWeightKg"];
            this.isActive = _data["isActive"];
            this.isFeatured = _data["isFeatured"];
        }
    }

    static fromJS(data: any): ServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["basePrice"] = this.basePrice;
        data["estimatedDurationHours"] = this.estimatedDurationHours;
        data["maxWeightKg"] = this.maxWeightKg;
        data["isActive"] = this.isActive;
        data["isFeatured"] = this.isFeatured;
        return data;
    }
}

export interface IServiceDto {
    id?: string;
    categoryId?: string;
    name?: string | undefined;
    description?: string | undefined;
    basePrice?: number;
    estimatedDurationHours?: number;
    maxWeightKg?: number;
    isActive?: boolean;
    isFeatured?: boolean;
}

export class ServiceDtoPagedResponse implements IServiceDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    readonly totalPages?: number;
    totalRecords?: number;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;
    data?: ServiceDto[] | undefined;

    constructor(data?: IServiceDtoPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            (this as any).totalPages = _data["totalPages"];
            this.totalRecords = _data["totalRecords"];
            (this as any).hasPreviousPage = _data["hasPreviousPage"];
            (this as any).hasNextPage = _data["hasNextPage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ServiceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServiceDtoPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceDtoPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalRecords"] = this.totalRecords;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IServiceDtoPagedResponse {
    pageNumber?: number;
    pageSize?: number;
    totalPages?: number;
    totalRecords?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
    data?: ServiceDto[] | undefined;
}

export class VerifyOtpCommand implements IVerifyOtpCommand {
    phoneNumber?: string | undefined;
    code?: string | undefined;

    constructor(data?: IVerifyOtpCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): VerifyOtpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyOtpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["code"] = this.code;
        return data;
    }
}

export interface IVerifyOtpCommand {
    phoneNumber?: string | undefined;
    code?: string | undefined;
}

export class WalletTopUpRequest implements IWalletTopUpRequest {
    amountValue?: number;
    paymentMethod?: PaymentMethod;

    constructor(data?: IWalletTopUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amountValue = _data["amountValue"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): WalletTopUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WalletTopUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountValue"] = this.amountValue;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

export interface IWalletTopUpRequest {
    amountValue?: number;
    paymentMethod?: PaymentMethod;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}